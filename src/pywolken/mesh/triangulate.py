"""2.5D Delaunay triangulation â€” generate meshes from point clouds."""

from __future__ import annotations

from pathlib import Path
from typing import Any

import numpy as np
from scipy.spatial import Delaunay

from pywolken.core.pointcloud import PointCloud


class Mesh:
    """Triangle mesh with vertices and face indices.

    Attributes:
        vertices: (N, 3) float64 array of vertex positions.
        faces: (M, 3) int64 array of triangle vertex indices.
        vertex_colors: Optional (N, 3) uint8 array of RGB colors.
    """

    def __init__(
        self,
        vertices: np.ndarray,
        faces: np.ndarray,
        vertex_colors: np.ndarray | None = None,
    ) -> None:
        self.vertices = np.asarray(vertices, dtype=np.float64)
        self.faces = np.asarray(faces, dtype=np.int64)
        self.vertex_colors = vertex_colors

    @property
    def num_vertices(self) -> int:
        return len(self.vertices)

    @property
    def num_faces(self) -> int:
        return len(self.faces)

    def decimate(self, target_faces: int) -> Mesh:
        """Simple mesh decimation by random face removal.

        For production use, a proper edge-collapse decimation would be
        better. This is a basic approximation.

        Args:
            target_faces: Target number of faces to keep.

        Returns:
            New Mesh with reduced face count.
        """
        if target_faces >= self.num_faces:
            return self

        rng = np.random.default_rng(42)
        indices = rng.choice(self.num_faces, size=target_faces, replace=False)
        indices.sort()
        new_faces = self.faces[indices]

        # Remap vertices (keep only those referenced by remaining faces)
        used = np.unique(new_faces)
        remap = np.full(self.num_vertices, -1, dtype=np.int64)
        remap[used] = np.arange(len(used))

        new_vertices = self.vertices[used]
        new_faces = remap[new_faces]

        new_colors = None
        if self.vertex_colors is not None:
            new_colors = self.vertex_colors[used]

        return Mesh(new_vertices, new_faces, new_colors)

    def write_obj(self, path: str) -> None:
        """Write mesh to Wavefront OBJ format."""
        with open(path, "w") as f:
            f.write("# Generated by pywolken\n")
            for v in self.vertices:
                f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
            for face in self.faces:
                # OBJ uses 1-based indexing
                f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")

    def write_stl(self, path: str) -> None:
        """Write mesh to binary STL format."""
        import struct

        with open(path, "wb") as f:
            # 80-byte header
            f.write(b"pywolken STL" + b"\0" * 68)
            # Number of triangles
            f.write(struct.pack("<I", self.num_faces))

            for face in self.faces:
                v0, v1, v2 = self.vertices[face]
                # Compute normal
                edge1 = v1 - v0
                edge2 = v2 - v0
                normal = np.cross(edge1, edge2)
                norm = np.linalg.norm(normal)
                if norm > 0:
                    normal /= norm

                # Write: normal (3 floats), v0, v1, v2 (9 floats), attribute (1 short)
                f.write(struct.pack("<3f", *normal))
                f.write(struct.pack("<3f", *v0))
                f.write(struct.pack("<3f", *v1))
                f.write(struct.pack("<3f", *v2))
                f.write(struct.pack("<H", 0))  # attribute byte count

    def write_ply(self, path: str) -> None:
        """Write mesh to PLY format (ASCII)."""
        with open(path, "w") as f:
            f.write("ply\n")
            f.write("format ascii 1.0\n")
            f.write(f"element vertex {self.num_vertices}\n")
            f.write("property float x\n")
            f.write("property float y\n")
            f.write("property float z\n")
            if self.vertex_colors is not None:
                f.write("property uchar red\n")
                f.write("property uchar green\n")
                f.write("property uchar blue\n")
            f.write(f"element face {self.num_faces}\n")
            f.write("property list uchar int vertex_indices\n")
            f.write("end_header\n")

            for i, v in enumerate(self.vertices):
                line = f"{v[0]:.6f} {v[1]:.6f} {v[2]:.6f}"
                if self.vertex_colors is not None:
                    c = self.vertex_colors[i]
                    line += f" {c[0]} {c[1]} {c[2]}"
                f.write(line + "\n")

            for face in self.faces:
                f.write(f"3 {face[0]} {face[1]} {face[2]}\n")

    def write(self, path: str, **options: Any) -> None:
        """Write mesh to file (auto-detect format from extension)."""
        ext = Path(path).suffix.lower()
        if ext == ".obj":
            self.write_obj(path)
        elif ext == ".stl":
            self.write_stl(path)
        elif ext == ".ply":
            self.write_ply(path)
        else:
            raise ValueError(f"Unsupported mesh format: {ext}. Use .obj, .stl, or .ply")

    def __repr__(self) -> str:
        return f"Mesh({self.num_vertices:,} vertices, {self.num_faces:,} faces)"


def triangulate_2d(
    pc: PointCloud,
    max_edge_length: float | None = None,
) -> Mesh:
    """Create a 2.5D triangle mesh from a point cloud.

    Projects points onto XY plane for Delaunay triangulation,
    then uses the Z values for the 3D mesh vertices.

    Args:
        pc: Point cloud with X, Y, Z dimensions.
        max_edge_length: Optional maximum triangle edge length.
            Triangles with any edge longer than this are removed
            (useful for removing large triangles at convex hull edges).

    Returns:
        Mesh with Delaunay triangulation.
    """
    x, y, z = pc["X"], pc["Y"], pc["Z"]
    points_2d = np.column_stack([x, y])

    tri = Delaunay(points_2d)
    faces = tri.simplices

    # Remove long-edge triangles if requested
    if max_edge_length is not None:
        vertices_3d = np.column_stack([x, y, z])
        keep = np.ones(len(faces), dtype=bool)
        for i, face in enumerate(faces):
            v0, v1, v2 = vertices_3d[face]
            e1 = np.linalg.norm(v1 - v0)
            e2 = np.linalg.norm(v2 - v0)
            e3 = np.linalg.norm(v2 - v1)
            if max(e1, e2, e3) > max_edge_length:
                keep[i] = False
        faces = faces[keep]

    vertices = np.column_stack([x, y, z])

    # Add vertex colors if available
    colors = None
    if "Red" in pc and "Green" in pc and "Blue" in pc:
        r = pc["Red"].astype(np.float64)
        g = pc["Green"].astype(np.float64)
        b = pc["Blue"].astype(np.float64)
        # Normalize to 0-255 if values are in uint16 range
        if r.max() > 255:
            r = (r / 257).astype(np.uint8)
            g = (g / 257).astype(np.uint8)
            b = (b / 257).astype(np.uint8)
        else:
            r = r.astype(np.uint8)
            g = g.astype(np.uint8)
            b = b.astype(np.uint8)
        colors = np.column_stack([r, g, b])

    return Mesh(vertices, faces, colors)
